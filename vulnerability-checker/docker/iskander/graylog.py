# Export from Graylog:
# timestamp source username _request_id ctxt_result

# Dependencies
import argparse
import csv
import json
import logging
from packaging import version

import mysql.connector

import time

class WPVuln():
	"""
	CSV parser for Graylog to find vulnerable plugins and themes
	"""

	def __init__(self, csv_file, csv_out=False):
		self.CSV_FILE = csv_file

		# Path to vulnerability database; with trailing slash
		self.VULNS_PLUGINS = "../plugins-json/"
		self.VULNS_THEMES  = "themes-json/"
		self.VULNS_PATCHSTACK = "patchstack.json"

		logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(message)s")

		if csv_out:
			self.CSV_OUT = True
		else:
			self.CSV_OUT = False

		self.parse_csv()

	def parse_csv(self):
		plugins_dict = dict()

		logging.info("CSV parsing started")

		try:
			with open(self.CSV_FILE) as file:
				# https://flutterq.com/solved-python-csv-error-line-contains-null-byte/
				csv_reader = csv.reader((line.replace('\0','') for line in file))
				next(csv_reader)
				for row in csv_reader:
					for ctxt_result in {row[4]}:
						try:
							plugins = json.loads(ctxt_result)
							for plugin in plugins:
								if plugin["name"] not in plugins_dict:
									plugins_dict[plugin["name"]] = {}

								if plugin["version"] not in plugins_dict[plugin["name"]]:
									plugins_dict[plugin["name"]][plugin["version"]] = set()

								plugins_dict[plugin["name"]][plugin["version"]].add(row[2])

						except json.decoder.JSONDecodeError:
							pass

		except FileNotFoundError:
			logging.warning("No valid input file specified")

		logging.info("CSV parsing finished")
		self.CSV_DATA = plugins_dict

	def check_vulnerable_plugins_wpvulndb(self, usernames_log=False, threshold=0):
		for plugin, plugin_versions in self.CSV_DATA.items():
			try:
				with open(self.VULNS_PLUGINS+plugin) as file:
					json_data = json.loads(file.read())
					for vuln in json_data["data"]["vulnerabilities"]:
						for plugin_version, usernames in plugin_versions.items():
							if version.parse(plugin_version) < version.parse(vuln["fixed_in"]):
								affected_usernames = [user for user in usernames]
								affected_usernames_count = str(len(affected_usernames))
								
								if len(affected_usernames) >= threshold:
									print(f"{plugin:<50} {plugin_version:<15} INCIDENT COUNT: {affected_usernames_count:<5} {vuln['title']:<50}")

									# Print affected usernames
									if usernames_log:
										print(f"AFFECTED: {affected_usernames_count}")
										for affected_username in affected_usernames:
											print(f"{affected_username:>20}")
										print("*"*100)
			except:
				pass

	def check_vulnerable_plugins_patchstack(self, usernames_log=False, threshold=0, csvv=0):
		db = mysql.connector.connect(host="127.0.0.1", user="db_user", password="db_user_pass", database="app_db", port=6033)
		header = ["slug", "name", "affected", "current", "version", "date", "cvss", "description"]
		print(f"{header[0]:<50} {header[1]:<50} {header[2]:<10} {header[3]:<10} {header[4]:<10} {header[5]:<15} {header[6]:<10} {header[7]:<10}")

		data = self.CSV_DATA

		### CSV output to file 
		if self.CSV_OUT:
			with open("iskander-out.csv", mode="a") as csv_file:
				csv_data = csv.writer(csv_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
				csv_data.writerow(["slug", "plugin_name", "incident_count", "current_version", "affected_version", "report_date", "cvss", "vulnerability"])

		for plugin_slug, plugin_versions in data.items():
			for plugin_version in plugin_versions:
				cursor = db.cursor()
				sql = f"SELECT * FROM `patchstack` WHERE `slug` = '{plugin_slug}'"
				try:
					cursor.execute(sql)
					results = cursor.fetchall()
				except:
					results = []

				for result in results:
					cvss = result[6] if result[6] != None else ""
					if version.parse(plugin_version) <= version.parse(result[3]):

						if len(plugin_versions[plugin_version]) >= threshold:
							print(f"{result[1]:<50} {result[2]:<50} {len(plugin_versions[plugin_version]):<10} {plugin_version:<10} {result[3]:<10} {result[4]:<15} {cvss:<10} {result[5]:<10}")

							### Usernames
							if usernames_log:
								usernames = plugin_versions[plugin_version]
								print(f"AFFECTED: {len(plugin_versions[plugin_version])}")
								for affected_username in usernames:
									print(f"{affected_username:>20}")
								print("*"*100)
							### CSV output to file
							if self.CSV_OUT:
								with open("iskander-out.csv", mode="a") as csv_file:
									csv_data = csv.writer(csv_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
									csv_data.writerow([result[1], result[2], len(plugin_versions[plugin_version]), plugin_version, result[3], result[4], cvss, result[5]])

	def check_vulnerable_themes(self, usernames_log=False, threshold=0):
		for theme, theme_versions in self.CSV_DATA.items():
			try:
				with open(self.VULNS_THEMES+theme) as file:
					json_data = json.loads(file.read())
					for vuln in json_data["data"]["vulnerabilities"]:
						for theme_version, usernames in theme_versions.items():
							if version.parse(theme_version) < version.parse(vuln["fixed_in"]):
								affected_usernames = [user for user in usernames]
								affected_usernames_count = str(len(affected_usernames))

								if len(affected_usernames) >= threshold:
									print(f"{theme:<50} {theme_version:<15} INCIDENT COUNT: {affected_usernames_count:<5} {vuln['title']:<50}")

									# Print affected usernames
									if usernames_log:
										print(f"AFFECTED: {affected_usernames_count}")
										for affected_username in affected_usernames:
											print(f"{affected_username:>20}")
										print("*"*100)
			except:
				pass

if __name__ == "__main__":

# Searching example:
# python3 graylog.py --csv ../plugins_all.csv --type plugins --threshold 100 --csvv 5.0
	arguments = argparse.ArgumentParser(prog="graylog.py",
										description="Detects vulnerabilities in WordPress plugins and themes based on Graylog's CSV log")

	arguments.add_argument("--csv", dest="CSV_FILE", help="Specify input file", required=True)
	arguments.add_argument("--type", dest="TYPE", help="Specify scan type: plugins, themes", required=True)
	arguments.add_argument("--usernames", dest="USERNAMES", action="store_true", help="Specify if usernames should be shown")
	arguments.add_argument("--threshold", dest="THRESHOLD", type=int, default=1, help="Specify incident threshold")
	arguments.add_argument("--csvv", dest="CSVV", type=float, default=1, help="Specify incident threshold")

	# Output parameters
	arguments.add_argument("--csv-out", dest="CSVOUT", action="store_true", help="Specify incident threshold")

	args = arguments.parse_args()

	if args.TYPE == "plugins":
		wpvuln = WPVuln(args.CSV_FILE, (True if args.CSVOUT else False))
		wpvuln.check_vulnerable_plugins_patchstack(usernames_log=args.USERNAMES, threshold=args.THRESHOLD, csvv=args.CSVV)
	elif args.TYPE == "themes":
		wpvuln = WPVuln(args.CSV_FILE)
		wpvuln.check_vulnerable_themes(usernames_log=args.USERNAMES, threshold=args.THRESHOLD)
	else:
		logging.warning("No valid input type specified")
